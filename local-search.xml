<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>软件开发中那些”易错”词汇</title>
    <link href="/2024/03/14/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E4%B8%AD%E9%82%A3%E4%BA%9B%E2%80%9D%E6%98%93%E9%94%99%E2%80%9D%E8%AF%8D%E6%B1%87/"/>
    <url>/2024/03/14/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E4%B8%AD%E9%82%A3%E4%BA%9B%E2%80%9D%E6%98%93%E9%94%99%E2%80%9D%E8%AF%8D%E6%B1%87/</url>
    
    <content type="html"><![CDATA[<h1 id="一、软件工程"><a href="#一、软件工程" class="headerlink" title="一、软件工程"></a>一、软件工程</h1><h2 id="透明"><a href="#透明" class="headerlink" title="透明"></a>透明</h2><p>初学者可能在一些计算机相关的课程中，经常会听到“透明”这个词。实际上，计算机中的“透明”和我们现实生活中的“透明”不一样。现实生活中的“透明”是指我们能看见内部的结构，而在计算机中“透明”对于我们来说是看不见的意思。ps：和黑盒的意思很像~</p><h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>在软件开发中，经常会遇到“同步”这个词。但很多人在初学的时候，对这个词的理解可能会出现偏差。在实际生活中，我们对“同步”的理解是同时处理多件事情；但是在软件开发中，“同步”是指一件事处理完接着一件事处理，若处理时间很长要一直等待直到完成才能接着处理下一个。</p><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>说完了“同步”，与之经常出现的还有“异步”。软件开发中的“同步”是一件事处理完后接着一件事处理，而“异步”则是一件事还未处理完接着处理下一件事，直到那件未处理完的事件经过“较长时间”的响应后，掉过头来对其结果进行处理。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>进程中的一段代码，一个进程中可以有多段代码。本身不拥有资源（共享所在进程的资源）。</p><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>运行中的应用程序称为进程，拥有系统资源（CPU、内存）。</p><h2 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h2><p>单线程，可以理解为某一时间只能运行一次某一段代码。有的人经常会把“同步”和“单线程”的概念搞混，认为是一样的。“同步”强调的是空间的承接，而“单线程”更多的是强调时间的承接。</p><p>初学者往往把多线程作为单线程的迭代，认为多线程这名字一听就比单线程效率高。实际上，要结合不同的场景。在单核CPU计算密集型中，单线程比多线程快。ps：JavaScript是一种单线程语言。</p><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>多线程，可以理解为某一时间能对某一段代码同时运行。</p><p>在网络IO密集型中，多线程比单线程快。ps：Java、GoLang、Python都是支持多线程的语言。</p><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>单线程不存在线程安全问题。</p><p>多线程存在线程安全问题。在上述多线程的理解中，某一时间能对某一段代码同时运行，可能这段代码是在计算或IO，不同的线程同时对同一资源进行访问和修改，就会造成线程安全问题。</p><h2 id="串行"><a href="#串行" class="headerlink" title="串行"></a>串行</h2><p>指多个任务时，完成一个之后才能进行下一个 ，某时刻只能有一个任务被运行。ps：单线程就是串行</p><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>多个线程在单个核心运行，同一时间一个线程运行，系统不停切换线程，看起来像同时运行，实际上是线程不停切换。</p><p>并发，一般也存在于服务器、程序的性能表现上。吞吐量、TPS、QPS、并发数、响应时间（RT）、吞吐率概念</p><h2 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h2><p>在多核的情况下，每个线程分配给独立的核心，线程同时运行。</p><h2 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h2><p>阻塞就是在调用结果返回之前，线程一直在等待结果。</p><p>注意：同步不一定就是阻塞的，例如在同步的过程中并没有发生等待情况，那么就是同步非阻塞。同步、异步、阻塞、非阻塞概念</p><h2 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a>非阻塞</h2><p>非阻塞则是在不能立刻得到结果之前，线程不会一直等待结果。</p><p>注意：异步一定是非阻塞的（因为没有异步阻塞的场景-_-||，异步的目的就是为了不堵塞）。</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>两个或两个以上线程，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，互相等待，耗在那里，最后程序不得不终止。</p><h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><p>分布式是一个业务分拆多个子业务，部署在不同的服务器上。分布式，重在资源共享与加快计算机计算速度，目的是为了分散压力。</p><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><p>微服务，重在解耦合，使每个模块都独立，可以部署在同一台或不同服务器上，目的是分散能力。</p><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>同一个业务，部署在多个服务器上。</p><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>负载均衡的前提是集群，目的是把压力平均分给不同的服务器。</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>一般指对数据、文件资源的缓存。前端本地一般可以缓存数据、文件资源，后端一般缓存的是数据。常见的就是Redis缓存数据库。</p><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>初学者，可能会把消息队列理解成即时通讯功能。实际上消息队列中的消息指的不止是用户通讯消息，而是指的是程序中产生的任何数据。具体就不展开了。为什么使用消息队列？</p><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><p>初学者，可能会把用户前台当成前端，管理后台当成后端，别笑，我刚学的时候就这样以为的-_-||</p><p>前端是指构建出人看的见的，例如文字、颜色、布局、动画、交互动效、游戏画面的显示等等。</p><h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><p>后端是指人看不见的，是用来处理前端传来的数据，存储数据。像之前提到的分布式、微服务、消息队列等等都属于后端的内容。</p><h2 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h2><p>这里的Web，指的是人类对互联网的需求。</p><p>Web1.0，是指用户只能浏览一些文字、图片、视频等静态资源。</p><p>Web2.0，是指用户可以自己产生数据在互联网平台上，例如微信通信、发微博、点赞抖音等等。</p><p>Web3.0，其实还没有被准确定义的概念，初步理解为“去中心化”，用户产生的数据，不再属于某一个平台，而是属于用户本人。</p><h2 id="Web端-应用"><a href="#Web端-应用" class="headerlink" title="Web端&#x2F;应用"></a>Web端&#x2F;应用</h2><p>按照Web的定义，Web应该指的是互联网服务。但实际目前，国内对Web端&#x2F;应用的定义约定俗成为基于浏览器的网页端。</p><h2 id="PC端"><a href="#PC端" class="headerlink" title="PC端"></a>PC端</h2><p>PC端软件是一般是指电脑上的软件客户端。</p><h2 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h2><p>移动端一般包括手机、平板、智能穿戴设备等。</p><h2 id="IaaS"><a href="#IaaS" class="headerlink" title="IaaS"></a>IaaS</h2><p>IaaS (Infrastructure as a Service) 基础设施即服务，服务商提供服务器、硬件等相关基础设施。</p><h2 id="PaaS"><a href="#PaaS" class="headerlink" title="PaaS"></a>PaaS</h2><p>PaaS (Platform as a Service) 平台即服务，服务商提供操作系统等平台服务，包括 数据库软件，Web服务器，负载均衡器等。</p><h2 id="SaaS"><a href="#SaaS" class="headerlink" title="SaaS"></a>SaaS</h2><p>SaaS (Software as a Service) 软件即服务，服务商提供软件等服务，买家付费使用软件，例如：office 365，云CRM等。</p><h2 id="BaaS"><a href="#BaaS" class="headerlink" title="BaaS"></a>BaaS</h2><p>BaaS (Backend as a Service) 后端即服务，服务商提供后端特定场景服务，如 身份验证服务，推送服务，数据存储，文件存储等，买家按需计费获得相应服务。</p><h2 id="Faas"><a href="#Faas" class="headerlink" title="Faas"></a>Faas</h2><p>Faas (Function as a Service) 函数即服务，服务商提供运行平台，买家直接开发应用，部署在平台上，调用执行，按次计费。</p><h2 id="云计算"><a href="#云计算" class="headerlink" title="云计算"></a>云计算</h2><p>云计算(Cloud Computing)，可以理解为是全部“aaS”。</p><h2 id="云原生"><a href="#云原生" class="headerlink" title="云原生"></a>云原生</h2><p>云原生(Cloud Native)，实际上是云计算的一个扩充，云原生计算(Cloud Native Computing)，其不同于传统云计算的特点是：DevOps、Serverless容器化等。</p><h2 id="DevOps"><a href="#DevOps" class="headerlink" title="DevOps"></a>DevOps</h2><p>Dev是软件开发人员，Ops是IT运维技术人员。在传统开发流程，Dev和Ops的联系不紧密，目的冲突大，非常容易出现扯皮的现象，尤其在单体架构中。</p><p>而在微服务、容器化架构中，DevOps实际上就是把开发责任细分、运维责任细分&#x2F;难度降低。</p><h2 id="Serverless"><a href="#Serverless" class="headerlink" title="Serverless"></a>Serverless</h2><p>Serverless（即无服务器），并不是不用服务器了，开发者无需关心服务器的维护工作，而是交给云厂商。</p><h1 id="二、计算机组成原理-操作系统"><a href="#二、计算机组成原理-操作系统" class="headerlink" title="二、计算机组成原理&#x2F;操作系统"></a>二、计算机组成原理&#x2F;操作系统</h1><h2 id="32位-64位"><a href="#32位-64位" class="headerlink" title="32位&#x2F;64位"></a>32位&#x2F;64位</h2><p>表示CPU一次最大能处理的位数（字长）。一般跟通用寄存器的大小相同，例如X86 64位CPU，通用寄存器大小为64位，也就是8个字节。</p><h2 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h2><p>总线包括地址总线、数据总线、控制总线。</p><h2 id="地址总线"><a href="#地址总线" class="headerlink" title="地址总线"></a>地址总线</h2><p>地址总线的数量决定了寻址的范围（内存的大小范围），例如8086有20条地址总线，决定了能找到的内存最大为1MB。</p><p>一个地址总线可以表示0和1      2^20&#x3D;1,048,576 （个地址） 一个地址代表一个存储单元（1个字节）  1,048,576 Byte &#x3D; 1MB</p><h2 id="数据总线"><a href="#数据总线" class="headerlink" title="数据总线"></a>数据总线</h2><p>数据总线（宽度），指的是 CPU与内存之间一次性能传输多少数据，例如16条数据总线，一次性能传输16位二进制数，也就是两个字节。</p><h2 id="控制总线"><a href="#控制总线" class="headerlink" title="控制总线"></a>控制总线</h2><p>控制总线表示CPU对系统中其他器件的控制能力。有多少根控制总线，就意味这CPU提供了对外部器件的多少种控制。</p><h2 id="存储单元"><a href="#存储单元" class="headerlink" title="存储单元"></a>存储单元</h2><p>存储单元是内存中存储数据的基本单元（存储元），一个存储单元最大可以存储8位二进制数，也就是一个字节。</p><h2 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h2><p>是硬件内存中真正的地址。</p><h2 id="虚拟地址"><a href="#虚拟地址" class="headerlink" title="虚拟地址"></a>虚拟地址</h2><p>由操作系统提供，并且负责映射到物理地址。负责将虚拟地址转换为物理地址的是硬件CPU中的 内存管理单元（MMU）。</p><p>注意：程序员能看到的地址都是虚拟地址。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>TBS Tango2 异常总结</title>
    <link href="/2024/03/04/TBS%20Tango2%20%E5%BC%82%E5%B8%B8%E6%80%BB%E7%BB%93/"/>
    <url>/2024/03/04/TBS%20Tango2%20%E5%BC%82%E5%B8%B8%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>以下内容为自己总结整理的Tango2异常处理，避免各种坑。</p><span id="more"></span><h2 id="开机显示SD-Warning-STORAGE-WANING"><a href="#开机显示SD-Warning-STORAGE-WANING" class="headerlink" title="开机显示SD Warning &#x2F; STORAGE WANING"></a>开机显示SD Warning &#x2F; STORAGE WANING</h2><h3 id="遥控器连接地面站"><a href="#遥控器连接地面站" class="headerlink" title="遥控器连接地面站"></a>遥控器连接地面站</h3><p>打开Agent M&#x2F;X，打开遥控器，用USB连接，选择USB Agent（HID），点击Tango II （图标为FREEDOM TX），查看当前版本（如V1.35）。</p><h3 id="下载SD卡内容"><a href="#下载SD卡内容" class="headerlink" title="下载SD卡内容"></a>下载SD卡内容</h3><p>FREEDOM TX版本需要对应相应的SD卡内容（如V1.35则选择第3个）。</p><p><a href="https://www.team-blacksheep.com/tango2_sd_files%202019-12-24_0019.7z">Tango2 SD Card Contents download</a> (For Freedom TX 1.0X)<br><a href="https://www.team-blacksheep.com/tango2_sd_files%202019-04-03_0019.7z">Tango2 SD Card Contents download</a> (2020-04-03) (For Freedom TX 1.1X)<br><a href="https://www.team-blacksheep.com/tango2_sd_files_2021_03_17_0026.zip">Tango 2 SD Card Contents download</a> (For Freedom TX 1.2x &amp; 1.3x)</p><h3 id="格式化SD卡"><a href="#格式化SD卡" class="headerlink" title="格式化SD卡"></a>格式化SD卡</h3><p>用USB连接遥控器，选择USB Storage（SD），选中U盘，右键-格式化-文件系统选中FAT32-开始。</p><p>其实最好是拆下Tango2后壳，拔出SD卡，用读取器格式化和复制SD卡内容，用USB可能出现其他错误。</p><h3 id="将下载的SD卡内容复制到SD卡中"><a href="#将下载的SD卡内容复制到SD卡中" class="headerlink" title="将下载的SD卡内容复制到SD卡中"></a>将下载的SD卡内容复制到SD卡中</h3><p>格式化完成后，将下载的SD卡内容复制到U盘中。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
